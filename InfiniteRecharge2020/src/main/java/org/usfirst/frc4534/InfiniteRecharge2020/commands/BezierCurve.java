// // RobotBuilder Version: 2.0
// //
// // This file was generated by RobotBuilder. It contains sections of
// // code that are automatically generated and assigned by robotbuilder.
// // These sections will be updated in the future when you export to
// // Java from RobotBuilder. Do not put any code or make any change in
// // the blocks indicating autogenerated code or it will be lost on an
// // update. Deleting the comments indicating the section will prevent
// // it from being updated in the future.
// // Haha enjoy doing a git merge loser ヽ( •_)ᕗ

// package org.usfirst.frc4534.InfiniteRecharge2020.commands;
// import edu.wpi.first.wpilibj.command.Command;
// import org.usfirst.frc4534.InfiniteRecharge2020.Robot;
// import java.lang.Math;
// /**
//  *
//  */
// public class BezierCurve extends Command {

//     // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
//     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
//     double[] xList = new double[10];
//     double[] yList = new double[10];
//     int t;
//     double m_P0x;
//     double m_P0y;
//     double m_P1x;
//     double m_P1y;
//     double m_P2x;
//     double m_P2y;
//     double m_P3x;
//     double m_P3y;
//     double angle;
//     double distance;
//     double PI = 3.14159;
//     int speed = 10;
//     int m_precision;
//     boolean m_relative;
//     double m_ratio = 0.5;
//     int cycles = 0;
//     double pringle = 0;
//     double b;
//     double r;
//     double fangle;
//     // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
//     public BezierCurve(double P0x, double P0y, double P1x, double P1y, double P2x, double P2y, double P3x, double P3y, int precision, boolean relative, double ratio) {
//     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
//         // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

//         // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
//         // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
//         requires(Robot.driveTrain);

//     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
//     	m_P0x = P0y;
//     	m_P0y = P0x;
//     	m_P1x = P1y;
//     	m_P1y = P1x;
//     	m_P2x = P2y;
// 	    m_P2y = P2x;
//     	m_P3x = P3y;
// 	    m_P3y = P3x;
//     	m_precision = precision;
// 	    t = 0;
//     	angle = 0;
// 	    distance = 0;
//      	m_relative = relative;
//         pringle = Math.atan2(P1y - P0y, P1x - P0x);
//     }

//     // Called just before this Command runs the first time
//     @Override
//     protected void initialize() {
//         t = 1;
//         angle = 0;
//         distance = 0;
//         xList[6] = m_P0x;
//         xList[6] = m_P0y;
//         Robot.driveTrain.resetDistanceCounter();
//     }

//     // Called repeatedly when this Command is scheduled to run
//     @Override
//     protected void execute() {
//         if(Robot.driveTrain.getLeftDistanceCounter() + Robot.driveTrain.getRightDistanceCounter() / 2 >= r * angle || t == 1) {
//             Robot.driveTrain.resetDistanceCounter();
//             //Calculates time / precision of the lines. See https://upload.wikimedia.org/wikipedia/commons/d/db/B%C3%A9zier_3_big.gif
//             xList[0] = m_P0x + ((m_P1x - m_P0x) * ((double)t / m_precision)); //Grey line P0=P1 point x
//             yList[0] = m_P0y + ((m_P1y - m_P0y) * ((double)t / m_precision)); //Grey line P0=P1 point y
//             xList[1] = m_P1x + ((m_P2x - m_P1x) * ((double)t / m_precision)); //Grey line P1=P2 point x
//             yList[1] = m_P1y + ((m_P2y - m_P1y) * ((double)t / m_precision)); //Grey line P1=P2 point y
//             xList[2] = m_P2x + ((m_P3x - m_P2x) * ((double)t / m_precision)); //Grey line P2=P3 point x
//             yList[2] = m_P2y + ((m_P3y - m_P2y) * ((double)t / m_precision)); //Grey line P2=P3 point y
//             xList[3] = xList[0] + ((xList[1] - xList[0]) * ((double)t / m_precision)); //Green line point 1 x
//             yList[3] = yList[0] + ((yList[1] - yList[0]) * ((double)t / m_precision)); //Green line point 1 y
//             xList[4] = xList[1] + ((xList[2] - xList[1]) * ((double)t / m_precision)); //Green line point 2 x
//             yList[4] = yList[1] + ((yList[2] - yList[1]) * ((double)t / m_precision)); //Green line point 2 y
//             xList[5] = xList[3] + ((xList[4] - xList[3]) * ((double)t / m_precision)); //Blue line point x
//             yList[5] = yList[3] + ((yList[4] - yList[3]) * ((double)t / m_precision)); //Blue line point y
//             //Increments time
//             t++;
//             //Uses gyro to caculate angle difference (present angle to needed one)
//             if(m_relative == false)
//             {
//                 if(Robot.driveTrain.getGyroAngle() < 0)
//                 {
//                     angle = Math.atan2(yList[5] - yList[6], xList[5] - xList[6]) - ((Robot.driveTrain.getGyroAngle()% -360) / 360 * (2 * PI));
//                 }
//                 else
//                 {
//                     //angle = Math.atan2(yList[5] - yList[6], xList[5] - xList[6]) - ((Robot.driveTrain.getGyroAngle() % 360) / 360 * (2 * PI));
//                     angle = Math.atan2(yList[5] - yList[6], xList[5] - xList[6]) - pringle;
//                 }
//             }
//             //Uses current calculated angle to caculate angle difference (present angle to needed one), will assume first grey line represents robots current angle.
//             else
//             {
//                 fangle = Math.atan2(yList[5] - yList[6], xList[5] - xList[6]);
//                 angle = fangle - pringle;
//                 pringle = fangle;
//             }
//             //Makes sure the angle isn't over 90 (degrees), indicating a "cusp" error. If it is, lowers angle until it is below 90.
//             //For cusp see https://proxy.duckduckgo.com/iu/?u=http%3A%2F%2Fwww.sosmath.com%2Fcalculus%2Fdiff%2Fder09%2FImage02.gif&f=1
//             //note how you could rotate the two "wings" to remove the cusp and make a seamless curve like:
//             //https://proxy.duckduckgo.com/iur/?f=1&image_host=http%3A%2F%2Fwww.vitutor.com%2Fgeometry%2Fconics%2Fimages%2F106.gif&u=https://www.vitutor.com/geometry/conics/images/106.gif
//             if(angle > PI / 2) {
//                 while(angle > PI / 2) {
//                     angle = angle - PI;
//                 }
//             }
//             //Makes sure the angle isnt under -90 (degrees), indicating a "cusp" error. If it is, lowers angle until it is above -90.
//             if(angle < PI / -2) {
//                 while(angle < PI / -2) {
//                     angle = angle + PI;
//                 }
//             }
//             //Calculates distance needed to travel, based on current pos(list[6]) and target (List[5])
//             distance = Math.sqrt(Math.pow(xList[6] - xList[5], 2) + Math.pow(yList[6] - yList[5], 2));
//             //Shifts the "current" target point to the previous one slot.
//             xList[6] = xList[5];
//             yList[6] = yList[5];
//             //Testing values in dashboard for troubleshooting
//             }
//             if(!(distance == 0)) {
//                 //Calculates an arc on a circle that will go the distance while turning the angle
//                 b = (PI - angle) / 2;
//                 r = Math.sin(b) / (Math.sin(angle) / distance);
//                 //Testing values in dashboard for troubleshooting
//                 //Starts traveiling along the arc at speed (ratio). Goes until the distance is met.
//                 if(angle 
//                 > 0) Robot.driveTrain.TankDrive(m_ratio, ((r - 12) / (r + 12)) * m_ratio);
//                 if(angle < 0) Robot.driveTrain.TankDrive((r + 12) / (r - 12) * m_ratio, m_ratio);
//                 if(angle == 0) Robot.driveTrain.TankDrive(m_ratio, m_ratio);
//         }
//     }

//     // Make this return true when this Command no longer needs to run execute()
//     @Override
//     protected boolean isFinished() {
//         if(t >= m_precision + 1) return true;
//         else return false;
//     }

//     // Called once after isFinished returns true
//     @Override
//     protected void end() {
//         Robot.driveTrain.TankDrive(0, 0);
//     }

//     // Called when another command which requires one or more of the same
//     // subsystems is scheduled to run
//     @Override
//     protected void interrupted() {
//         Robot.driveTrain.TankDrive(0, 0);
//     }
// }

